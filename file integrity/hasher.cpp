#include "hasher.h" // Подключает hasher.h для доступа к HashAlgorithm и объявлению compute_hash
#include <openssl/evp.h> // Подключает OpenSSL EVP-интерфейс для вычисления хешей
#include <openssl/err.h> // Подключает OpenSSL для обработки ошибок (опционально, для отладки)
#include <fstream> // Подключает библиотеку для чтения файлов
#include <iomanip> // Подключает библиотеку для форматирования вывода (шестнадцатеричный формат)
#include <sstream> // Подключает библиотеку для работы с потоками строк (форматирование хеша)
#include <vector> // Подключает библиотеку для работы с векторами (буфер чтения)

// Пустая строка для читаемости

// Реализует CRC32 вручную
namespace { // Открывает анонимное пространство имён для вспомогательных функций CRC32, чтобы они были локальны для этого файла
    // Таблица CRC32 (полином 0xEDB88320)
    uint32_t crc32_table[256]; // Объявляет массив для таблицы CRC32, используемой для ускорения вычислений
    bool crc32_table_initialized = false; // Флаг, указывающий, инициализирована ли таблица

    // Инициализирует таблицу CRC32
    void init_crc32_table() { // Определяет функцию для инициализации таблицы CRC32
        for (uint32_t i = 0; i < 256; ++i) { // Перебирает все возможные байты (0–255)
            uint32_t crc = i; // Инициализирует crc текущим байтом
            for (int j = 0; j < 8; ++j) { // Выполняет 8 итераций для каждого бита
                if (crc & 1) { // Проверяет, установлен ли младший бит
                    crc = (crc >> 1) ^ 0xEDB88320; // Сдвигает вправо и применяет полином
                }
                else { // Если младший бит не установлен
                    crc >>= 1; // Просто сдвигает вправо
                } // Завершает проверку бита
            } // Завершает цикл по битам
            crc32_table[i] = crc; // Сохраняет результат в таблице
        } // Завершает цикл по байтам
        crc32_table_initialized = true; // Устанавливает флаг инициализации
    } // Завершает функцию init_crc32_table

    // Вычисляет CRC32 для буфера
    uint32_t compute_crc32(const std::vector<unsigned char>& buffer) { // Определяет функцию для вычисления CRC32 буфера
        if (!crc32_table_initialized) { // Проверяет, инициализирована ли таблица
            init_crc32_table(); // Инициализирует таблицу, если нужно
        } // Завершает проверку
        uint32_t crc = 0xFFFFFFFF; // Инициализирует crc начальным значением (все биты 1)
        for (unsigned char byte : buffer) { // Перебирает каждый байт в буфере
            crc = (crc >> 8) ^ crc32_table[(crc & 0xFF) ^ byte]; // Обновляет crc с использованием таблицы
        } // Завершает цикл по байтам
        return crc ^ 0xFFFFFFFF; // Инвертирует конечное значение и возвращает
    } // Завершает функцию compute_crc32
} // Закрывает анонимное пространство имён

// Пустая строка для читаемости

std::string compute_hash(const std::string& file_path, HashAlgorithm algo) { // Определяет функцию compute_hash для вычисления хеша файла
    // Открывает файл в двоичном режиме
    std::ifstream file(file_path, std::ios::binary); // Открывает файл по file_path в двоичном режиме
    if (!file.is_open()) { // Проверяет, удалось ли открыть файл
        return ""; // Возвращает пустую строку при ошибке
    } // Завершает проверку

    // Пустая строка для читаемости

    // Буфер для чтения файла
    const size_t buffer_size = 4096; // Определяет размер буфера (4 КБ) для чтения файла
    std::vector<unsigned char> buffer(buffer_size); // Создаёт вектор для хранения буфера

    // Пустая строка для читаемости

    // Инициализация контекста хеша с использованием EVP
    EVP_MD_CTX* ctx = EVP_MD_CTX_new(); // Создаёт новый контекст EVP для хеширования
    if (!ctx) { // Проверяет, удалось ли создать контекст
        file.close(); // Закрывает файл
        return ""; // Возвращает пустую строку при ошибке
    } // Завершает проверку

    const EVP_MD* md = nullptr; // Указатель на метод хеширования (EVP_MD)
    if (algo == HashAlgorithm::MD5) { // Проверяет, выбран ли MD5
        md = EVP_md5(); // Устанавливает метод MD5
    }
    else if (algo == HashAlgorithm::SHA256) { // Проверяет SHA-256
        md = EVP_sha256(); // Устанавливает метод SHA-256
    }
    else if (algo == HashAlgorithm::SHA512) { // Проверяет SHA-512
        md = EVP_sha512(); // Устанавливает метод SHA-512
    } // Завершает выбор метода (CRC32 обрабатывается отдельно)

    if (md && EVP_DigestInit_ex(ctx, md, nullptr) != 1) { // Инициализирует контекст, если метод определён
        EVP_MD_CTX_free(ctx); // Освобождает контекст при ошибке
        file.close(); // Закрывает файл
        return ""; // Возвращает пустую строку
    } // Завершает проверку инициализации

    // Пустая строка для читаемости

    // Чтение файла и обновление хеша
    while (file) { // Читает файл, пока не достигнут конец
        file.read(reinterpret_cast<char*>(buffer.data()), buffer_size); // Читает блок данных в буфер
        std::streamsize bytes_read = file.gcount(); // Получает количество прочитанных байтов
        if (bytes_read > 0) { // Проверяет, были ли прочитаны данные
            if (md && EVP_DigestUpdate(ctx, buffer.data(), bytes_read) != 1) { // Обновляет хеш
                EVP_MD_CTX_free(ctx); // Освобождает контекст при ошибке
                file.close(); // Закрывает файл
                return ""; // Возвращает пустую строку
            } // Завершает проверку
        } // Завершает проверку данных
    } // Завершает цикл чтения

    // Пустая строка для читаемости

    // Завершение вычисления хеша для MD/SHA
    std::string hash;
    if (md) { // Проверяет, использовался ли метод (MD5/SHA)
        unsigned char hash_value[EVP_MAX_MD_SIZE]; // Создаёт массив для хеша (максимальный размер)
        unsigned int hash_length; // Переменная для длины хеша
        if (EVP_DigestFinal_ex(ctx, hash_value, &hash_length) != 1) { // Завершает вычисление
            EVP_MD_CTX_free(ctx); // Освобождает контекст
            file.close(); // Закрывает файл
            return ""; // Возвращает пустую строку
        } // Завершает проверку
        std::stringstream ss; // Создаёт строковый поток для форматирования
        for (unsigned int i = 0; i < hash_length; ++i) { // Перебирает байты хеша
            ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash_value[i]; // Форматирует байт как два шестнадцатеричных символа
        } // Завершает цикл
        hash = ss.str(); // Сохраняет хеш как строку
    } // Завершает блок MD/SHA

    // Пустая строка для читаемости

    // Вычисление CRC32
    else if (algo == HashAlgorithm::CRC32) { // Проверяет, выбран ли CRC32
        uint32_t crc = 0; // Инициализирует переменную для CRC32
        file.clear(); // Сбрасывает флаги состояния файла
        file.seekg(0); // Возвращает указатель в начало файла
        while (file) { // Читает файл заново
            file.read(reinterpret_cast<char*>(buffer.data()), buffer_size); // Читает блок
            std::streamsize bytes_read = file.gcount(); // Получает байты
            if (bytes_read > 0) { // Проверяет данные
                buffer.resize(bytes_read); // Урезает буфер
                crc = compute_crc32(buffer); // Вычисляет CRC32
            } // Завершает проверку
        } // Завершает цикл
        std::stringstream ss; // Создаёт поток
        ss << std::hex << std::setw(8) << std::setfill('0') << crc; // Форматирует CRC32 как 8-символьную строку
        hash = ss.str(); // Сохраняет хеш
    } // Завершает блок CRC32

    // Пустая строка для читаемости

    // Освобождение ресурсов и закрытие файла
    EVP_MD_CTX_free(ctx); // Освобождает контекст EVP
    file.close(); // Закрывает файл
    return hash; // Возвращает вычисленный хеш
} // Завершает функцию compute_hash